#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subsection
Genetic Hybrid Algorithms
\end_layout

\begin_layout Standard
In this section a genetic algorithm will be combined with a local search
 algorithm to approximate the optimal solution.
 The first part of this section will give an example of a genetic hybrid
 algorithm.
 The second part will show how this algorithm perform compared to other
 genetic hybrids.
\end_layout

\begin_layout Subsubsection
Shifting Bottleneck Procedure
\end_layout

\begin_layout Standard
This example is a combination of a genetic algorithm with a shifting bottleneck
 procedure.
 
\emph on
The shifting bottleneck procedure (SBP)
\emph default
 is an extensively used heuristic to approximate optimal solutions for the
 job shop problem.
 Given a JSP-instance that consists of a multi-machine schedule and a certain
 number of jobs.
 The machines are denoted as 
\begin_inset Formula $M_{0},M_{1},...,M_{n}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The SBP starts by creating a partial schedule of just the first machine
 
\begin_inset Formula $M_{0}$
\end_inset

.
 This 
\begin_inset Formula $M_{0}$
\end_inset

 will be optimized by the use of a dispatcher rule.
 A number of dispatcher rules for JSP are listed in Section 3.1.
 Optimizing a machine in JSP means generating a schedule of all operations
 that must be done by this specific machine.
 The order in which operations are chosen is decided by the dispatcher rule.
\end_layout

\begin_layout Standard
The SBP then continues by iteratively bringing another machine (named the
 bottleneck) into the schedule.
 On every iteration SBP locally reoptimizes the current partial schedule
 for each individual machine as descibed above, one by one.
 In essence, this reduces the JSP from solving a multi-machine scheduling
 problem to repeatedly solving single-machine scheduling problems
\begin_inset CommandInset citation
LatexCommand cite
key "Adams-and-Joseph-1988"

\end_inset

.
 By improving partial schedules constructed in previous iterations, before
 entering the next iteration, SBP is called an constructive algorithm combined
 with local search
\begin_inset CommandInset citation
LatexCommand cite
key "Cesar-Rego-and-Renato-Duarte-2009"

\end_inset

.
\end_layout

\begin_layout Standard
Now consider SB-GA, a hybrid genetic approach for the SBP, proposed by Dorndorf
 and Pesch
\begin_inset CommandInset citation
LatexCommand cite
key "Dorndorf199525"

\end_inset

.
 In this approach a chromosome is denoted as an encoded list of ordered
 machines.
 Genetic algorithms evolve those chromosomes in order to retrieve better
 sequences of machines for SBP.
 The bottleneck shifting procedure is used to derive a schedule from these
 encodings of machine sequences.
 Resulting schedules differ greatly in quality, depending on the sequence
 of bottleneck machines
\begin_inset CommandInset citation
LatexCommand cite
key "cheng99"

\end_inset

.
\end_layout

\begin_layout Standard
The procedure of deriving a schedule from the chromosome works as follows:
\end_layout

\begin_layout Itemize
-Let 
\begin_inset Formula $M_{0}$
\end_inset

 be the set of already sequenced machines (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $M_{0}=\emptyset$
\end_inset

 at the start)
\end_layout

\begin_layout Itemize
-Given chromosome 
\begin_inset Formula $[m_{1},m_{2},m_{3},...,m_{m}]$
\end_inset

.
\end_layout

\begin_layout Enumerate
Start with 
\begin_inset Formula $M_{0}=\emptyset$
\end_inset

 and 
\begin_inset Formula $i=1$
\end_inset

.
\end_layout

\begin_layout Enumerate
Use a dispatcher rule to solve partial schedule (job sequence) for machine
 
\begin_inset Formula $m_{i}$
\end_inset

 and add 
\begin_inset Formula $m_{i}$
\end_inset

 to 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $M_{0}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Re-optimize the sequence of each critical machine 
\begin_inset Formula $m_{i}\in M_{0}$
\end_inset

 in turn, while keeping the other sequences fixed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $i=1+1$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $i>m$
\end_inset

, stop.
 Else, return to step 2.
\end_layout

\begin_layout Standard
This genetic shifting bottleneck procedure differs from the standard shifting
 bottleneck heuristic in a very crucial way.
 In the genetic approach the bottleneck is not a criterion for the choice
 of the next machine, because this is determined by the given chromosome.
 Thus, this genetic approach doesn't need to identify a bottleneck machine
 on every iteration
\begin_inset CommandInset citation
LatexCommand cite
key "cheng99"

\end_inset

.
 In the next section, SB-GA will be tested for time and quality and will
 be compared to other genetic hybrids.
\end_layout

\begin_layout Subsubsection
Performance
\end_layout

\begin_layout Standard
To illustrate the effectiveness of the genetic algorithm above, a set of
 test problems will be needed.
 Consider the following two test suites of standard JSP problems: FT and
 LA.
 
\end_layout

\begin_layout Standard
UITLEG FT PROBLEMEN
\end_layout

\begin_layout Standard
UITLEG LA PROBLEMEN
\end_layout

\begin_layout Standard
---------------------------------
\end_layout

\begin_layout Standard
As benchmarks, we will use FT06, FT10 (the notorious 10x10 JSP, mentioned
 in Section 1), FT20 and LA01-LA40.
 This is the typical test suite for JSP.
\end_layout

\begin_layout Standard
AT&T Labs Research made a comparison in 2002 between their self-introduced
 GLS and 12 other approaches to JSP, including SB-GA
\begin_inset CommandInset citation
LatexCommand cite
key "Goncalves_ahybrid"

\end_inset

.
 In their results, SB-GA was able to solve 35 out of 43 instances, of which
 17 optimally.
 In other words, almost half of these solutions were equal to the 
\emph on
best-known solution
\emph default
 (BKS).
\end_layout

\begin_layout Standard
The 
\emph on
average relative deviation
\emph default
 (ARD) for SB-GA, with respect to the BKS has been found to be 1,42%, which
 is better than the genetic hybrids of Aarts
\begin_inset CommandInset citation
LatexCommand cite
key "AARTSE.H.L.:1994"

\end_inset

 and Croce
\begin_inset CommandInset citation
LatexCommand cite
key "Croce1995"

\end_inset

.
 Only Gon√ßalves's GLS algorithm
\begin_inset CommandInset citation
LatexCommand cite
key "Goncalves_ahybrid"

\end_inset

 showed better results, solving all 43 test problems with an ARD of 0,90%.
\end_layout

\begin_layout Standard
Another benchmark for SB-GA was made in 1996 by Vaessens, Aarts and Lenstra
\begin_inset CommandInset citation
LatexCommand cite
key "Vaessens-Aarts-Lenstra-1996"

\end_inset

, showing that SB-GA found solutions closer to BKS than other genetic algorithms
, and in less time.
 In seemed SB-GA worked especially well for the most difficult 15x15 problems
 (LA36-LA40).
 This benchmark shows an ARD of 1,48%, which is close to the 1,42% AT&T
 found.
 Lenstra also approximated the 
\emph on
Computer Independent Computation Time 
\emph default
(CICT) for SB-GA
\emph on
 
\emph default
at 4500.
 Compared to other hybrid GAs this is rather small, but compared to the
 non-genetic SPB this is rather big.
 SBP as proposed by Adams
\begin_inset CommandInset citation
LatexCommand cite
key "Adams-and-Joseph-1988"

\end_inset

 has a CICT of just 60 but a relatively large ARD of 2,50%.
\end_layout

\begin_layout Standard
From both benchmarks it can be observed that SB-GA is best used for the
 most difficult problems.
 Namely, in these cases the low ARD makes up for the relatively large computatio
n time.
 So, SB-GA is recommendable over standard SBP where it is worth more to
 find a compact schedule than a quick solution.
\end_layout

\begin_layout Standard
Unfortunately, more recent publications of SB-GA benchmarks for the standard
 JSP are unavailable.
 This is because in the last decade, scientists have moved forward from
 a standard JSP to more complex problems like the flexible multi-objective
 JSP (fJSP), which is beyond the scope of this paper.
\end_layout

\end_body
\end_document
