#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Subsection
Genetic Local Search
\end_layout

\begin_layout Standard
This section will focus on genetic algorithms that heavily rely on local
 search, a common form of 
\emph on
hybrid genetic algorithms
\emph default
.
 Genetic algorithms are designed to be effective at global search, but converge
 slowly.
 Local search on the other hand is effective at fine-tuning but often falls
 into local maxima, as shown in 
\emph on
section 2.2
\emph default
: Local Search.
 The hybrid approach combines the best of both worlds by combining genetic
 algorithms that perform global search to avoid falling into local maxima
 with local search that handles the fine-tuning
\begin_inset CommandInset citation
LatexCommand cite
key "cheng99"

\end_inset

.
 In this section, the general principles of combining genetic algorithms
 with local search are introduced first.
 Next, some state-of-the-art hybrid genetic algorithms to the job shop problem
 are presented in this section.
\end_layout

\begin_layout Subsubsection
Combining genetic algorithms with local search
\end_layout

\begin_layout Standard
Typical genetic algorithms recombine parents, followed by mutation, in order
 to produce new chromosomes.
 Selection of chromosomes is based on their fitness.
 In standard genetic algorithms, this fitness can be calculated immediately
 after 'birth' by using a fitness function as shown in section 3.2.3.
 In genetic algorithms combined with local search, selection is based on
 fitness after performing local search.
 This means offspring will be improved and these improvements will be passed
 on trough crossover.
 In essence, this causes offspring to 'learn', a principle called 
\emph on
local optimization
\emph default
.
 An example of pseudo code for such an optimization is shown in listing
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Pseudocode-for-optimization"

\end_inset

 and illustrated in figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-recombination-,-local"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

  t=0
\end_layout

\begin_layout Plain Layout

  initialize P(t) job sequences
\end_layout

\begin_layout Plain Layout

  localsearch to improve chromosomes
\end_layout

\begin_layout Plain Layout

  evaluate P(t)
\end_layout

\begin_layout Plain Layout

  while (not termination condition) do
\end_layout

\begin_layout Plain Layout

    recombine P(t) by crossover and mutation
\end_layout

\begin_layout Plain Layout

    localsearch to improve chromosomes
\end_layout

\begin_layout Plain Layout

    evaluate P(t)
\end_layout

\begin_layout Plain Layout

    select to new population P(t)
\end_layout

\begin_layout Plain Layout

    t++
\end_layout

\begin_layout Plain Layout

  endwhile
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Pseudocode-for-optimization"

\end_inset

Pseudo-code for optimization
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/pseudo-to-figure.pdf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:The-recombination-,-local"

\end_inset

The recombination-, local search-, and evaluation-steps in the pseudo-code
\end_layout

\end_inset


\end_layout

\end_inset

Selection as seen in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-recombination-,-local"

\end_inset

 is based on some JSP-specific priority-based dispatching rule, as described
 in 
\emph on
section 3.1
\emph default
.
 Local search can be substituted by any form of local search algorithm that
 converts a given chromosome into a feasible solution.
 Such a local search algorithm will be explained in the following section.
\end_layout

\begin_layout Subsubsection
Shifting Bottleneck Procedure
\end_layout

\begin_layout Standard
The first example is a combination of a genetic algorithm with a bottleneck
 shifting procedure.
 
\emph on
The shifting bottleneck procedure (SBP)
\emph default
 is an extensively used heuristic to approach optimal solutions for the
 job shop problem.
 Given a JSP-instance that consists of a multi-machine schedule and a certain
 number of jobs.
 The SBP starts by creating a partial schedule of just the first machine.
 The SBP then continues by iteratively bringing another machine (named the
 bottleneck) into the schedule.
 On every iteration SPB locally reoptimizes the current partial schedule
 for each individual machine, one by one.
 In essence, this reduces the JSP from solving a multi-machine scheduling
 problem to repeatedly solving single-machine scheduling problems 
\begin_inset CommandInset citation
LatexCommand cite
key "Adams-and-Joseph-1988"

\end_inset

.
 By improving partial schedules constructed in previous iterations, before
 entering the next iteration, SBP is called an constructive algorithm combined
 with local search.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Cesar-Rego-and-Renato-Duarte-2009"

\end_inset

.
\end_layout

\begin_layout Standard
Now consider the hybrid genetic approach for the SBP.
 In this approach a chromosome is denoted as an encoded list of ordered
 machines.
 Genetic algorithms evolve those chromosomes in order to retrieve better
 sequences of machines for SPB.
 The bottleneck shifting procedure is used to derive a schedule from these
 encodings of machine sequences.
 Resulting schedules differ greatly in quality, depending on the sequence
 of bottleneck machines 
\begin_inset CommandInset citation
LatexCommand cite
key "cheng99"

\end_inset

.
\end_layout

\begin_layout Standard
The procedure of deriving a schedule from the chromosome works as follows:
\end_layout

\begin_layout Itemize
-Let 
\begin_inset Formula $M_{0}$
\end_inset

 be the set of already sequenced machines (
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $M_{0}=\emptyset$
\end_inset

 at the start)
\end_layout

\begin_layout Itemize
-Given chromosome 
\begin_inset Formula $[m_{1},m_{2},m_{3},...m_{m}]$
\end_inset

.
\end_layout

\begin_layout Enumerate
Start with 
\begin_inset Formula $M_{0}=\emptyset$
\end_inset

 and 
\begin_inset Formula $i=1$
\end_inset

.
\end_layout

\begin_layout Enumerate
Optimally solve partial schedule (job sequence) for machine 
\begin_inset Formula $m_{i}$
\end_inset

 and add 
\begin_inset Formula $m_{i}$
\end_inset

 to 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $M_{0}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Re-optimize the sequence of each critical machine 
\begin_inset Formula $m_{i}\in M_{0}$
\end_inset

 in turn, while keeping the other sequences fixed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $i=1+1$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $i>m$
\end_inset

, stop.
 Else, return to step 2.
\end_layout

\begin_layout Standard
This genetic shifting bottleneck procedure differs from the standard shifting
 bottleneck heuristic in a very crucial way.
 In the genetic approach the bottleneck is not a criterion for the choice
 of the next machine, because this is determined by the given chromosome.
 Thus, this genetic approach doesn't need to identify a bottleneck machine
 on every iteration 
\begin_inset CommandInset citation
LatexCommand cite
key "cheng99"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Beam search
\end_layout

\begin_layout Standard
---Combining genetic algorithms with beam search has been proposed by Holsapple.
\end_layout

\begin_layout Standard
---In this approach a chromosome is denoted as an encoded job sequence.
\end_layout

\begin_layout Standard
---Genetic algorithm manipulate the job sequence.
\end_layout

\begin_layout Standard
---Filtered beam search generate 'best' schedule for give job sequence (chromoso
me)
\end_layout

\begin_layout Standard
\begin_inset Foot
status open

\begin_layout Plain Layout
@Peter: More examples of hybrid genetics, with different chromosome-representati
ons (like beam search), so comparisons can be made? Or dig deeper into SPB?
\end_layout

\end_inset


\end_layout

\end_body
\end_document
