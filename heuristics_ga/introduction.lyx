#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
Algorithmic design is a major research area in computer science.
 Computer scientists try to solve problems using algorithms that run in
 less time using less memory.
 In some cases problems can be solved already and scientist are just looking
 for optimizations but in many cases there is not yet an (exact) algorithm
 to the problem at all.
 This section will explain some basics of the computational complexity theory.
\end_layout

\begin_layout Paragraph
Types of problems 
\end_layout

\begin_layout Standard
A decision problem is a problem which an algorithm can answer with 
\emph on
yes
\emph default
 or 
\emph on
no
\emph default
.
 There are two kinds of machines: deterministic and non-deterministic.
 Deterministic machine is a regular machine, doing one process at a time.
 A non-deterministic machine can have parallelism.
 It allows multiple instructions for any state when it reads any input symbol.
\begin_inset CommandInset citation
LatexCommand cite
key "sipser"

\end_inset


\end_layout

\begin_layout Standard
A decision problem is in 
\series bold
P
\series default
 if there exists an algorithm that can solve the problem in polynomial time
 using a single-tape Turing machine.
 A decision problem is in 
\series bold
NP
\series default
 if there is a polynomial-time algorithm that gets an answer on the non-determin
istic machine.
 All problems in NP can also be verified in polynomial time.
 Verifying means that for a given answer it can be verified if it is a valid
 answer.
 Problems in P are also in NP.
\end_layout

\begin_layout Standard
A problem is 
\series bold
NP-complete
\series default
 if it is in NP and no other NP problem is more than polynomial factor harder.
 NP-complete problems are polynomial-time reducible to all other NP-problems.
 Reducible means that for problems A and B a solution for A can be transformed
 to solution of B.
 So all yes-instances of A will be transformed to yes-instances of B and
 all no-instances of A will be transformed to no-instances of B.
 A NP-complete problem is in NP and is also NP-hard.
\end_layout

\begin_layout Standard
A problem is 
\series bold
NP-hard
\series default
 if it is at least as hard as NP-complete problem.
 These problems cannot be solved by a nondeterministic machine in polynomial
 time.
 If NP-hard problem is not NP-complete, means it is also not in NP.
 This is the set of hardest problems.
 The most interesting problems found in real life are in this set.
 Like mentioned above JSP is also NP-hard.
\end_layout

\begin_layout Paragraph
Types of algorithms
\end_layout

\begin_layout Standard
There are also a lot of ways to solve a problem.
 There are exact algorithms that give an optimal therefore best solution
 to the problem.
 There are also heuristic algorithms which approximate the optimal solution
 to a problem within an acceptable amount of time but without any guarantees
 that the obtained answer is optimal.
 For example local search or genetic algorithms can be used.
 These two are different specific types of heuristics.
 Local search can be used to optimize solutions in discrete search space
 to a local optimum.
 Genetic alghoritms use the same strategy to solve problems as nature does.
 They try to evolve a solution to a problem using the natural selection
 and the survival of the fittest.
 Genetic local search (GLS) combines these two methods, getting an effective
 global search from GA and effective fine-tuning from local search.
 GLS will be discussed in the last chapter of this section.
\end_layout

\end_body
\end_document
